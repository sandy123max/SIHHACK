# -*- coding: utf-8 -*-
"""Algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WgKV9V0XA7JGgtkLidFzTFmwCa0QsiSw
"""



"""Progress percentage model

"""

#Import required model
import cv2
import numpy as np

#Function for progress percentage
def calculate_completion_percentage(prev_image_path, new_image_path):
    # Load the previous and current images
    prev_image = cv2.imread(prev_image_path)
    new_image = cv2.imread(new_image_path)

    # Convert images to grayscale
    prev_gray = cv2.cvtColor(prev_image, cv2.COLOR_BGR2GRAY)
    new_gray = cv2.cvtColor(new_image, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian blur to reduce noise
    prev_gray_blur = cv2.GaussianBlur(prev_gray, (5, 5), 0)
    new_gray_blur = cv2.GaussianBlur(new_gray, (5, 5), 0)

    # Compute the absolute difference between the two images
    diff_image = cv2.absdiff(prev_gray_blur, new_gray_blur)

    # Threshold the difference image to highlight significant changes
    _, thresh_image = cv2.threshold(diff_image, 25, 255, cv2.THRESH_BINARY)

    # Calculate the percentage of changed pixels
    total_pixels = thresh_image.size
    changed_pixels = np.count_nonzero(thresh_image)

    # Calculate the percentage of change
    change_percentage = (changed_pixels / total_pixels) * 100

    # Assume the previous completion percentage, let's say it's stored somewhere
    previous_completion = 70  # Just an example, you can set it dynamically

    # Calculate the new completion percentage
    # You can adjust the multiplier depending on how you define progress
    new_completion = previous_completion + (change_percentage / 10)

    # Limit completion to 100%
    new_completion = min(new_completion, 100)
    previous_completion=new_completion

    return new_completion

#Function call ,Running of function
prev_image_path = '/current_construction_image.png' # Removed extra file extension
new_image_path = '/previous_construction_image1.png' # Removed extra file extension

completion_percentage = calculate_completion_percentage(prev_image_path, new_image_path)
print(f"Updated completion percentage: {completion_percentage:.2f}%")

"""Clustering data"""

#Import required libraries
import numpy as np
import cv2
import os
from sklearn.cluster import KMeans
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet50 import preprocess_input
from tensorflow.keras.preprocessing import image
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

#Function features extraction
resnet_model = ResNet50(weights='imagenet', include_top=False, pooling='avg')

def extract_features(img_path):
    """Extract features from an image using ResNet50."""
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)

    # Extract features
    features = resnet_model.predict(img_array)
    return features.flatten()

def load_and_extract_features(image_folder):
    """Load all images from a folder and extract features."""
    image_features = []
    image_paths = []

    for filename in os.listdir(image_folder):
        if filename.endswith(".jpg") or filename.endswith(".png"):
            img_path = os.path.join(image_folder, filename)
            image_paths.append(img_path)

            # Extract features
            features = extract_features(img_path)
            image_features.append(features)

    return np.array(image_features), image_paths


# Perform PCA for dimensionality reduction(optimality)
def reduce_dimensionality(features, n_components=18):
    pca = PCA(n_components=n_components)
    reduced_features = pca.fit_transform(features)
    return reduced_features
#Image clustering
def cluster_images(features, num_clusters=3):
    """Cluster the images using K-Means."""
    kmeans = KMeans(n_clusters=num_clusters, random_state=42)
    labels = kmeans.fit_predict(features)
    return labels

# Plot the clustered images
def plot_clusters(labels, image_paths):
    """Visualize the clustered images."""
    for cluster_id in np.unique(labels):
        print(f"Cluster {cluster_id}:")
        cluster_indices = np.where(labels == cluster_id)[0]
        plt.figure(figsize=(12, 6))
        for i, idx in enumerate(cluster_indices[:5]):  # Display first 5 images per cluster
            img = cv2.imread(image_paths[idx])
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            plt.subplot(1, 5, i + 1)
            plt.imshow(img)
            plt.axis('off')
        plt.show()

# Main flow
image_folder = '/bin/X11/construct_image' # Folder containing construction images
image_features, image_paths = load_and_extract_features(image_folder)

# Reduce dimensionality to 50 components using PCA
reduced_features = reduce_dimensionality(image_features, n_components=18)

# Cluster the images using K-Means (adjust the number of  qy67mak un  clusters as needed)
num_clusters = 3  # Change this based on expected room types (e.g., rooms, halls, kitchen, etc.)
labels = cluster_images(reduced_features, num_clusters=num_clusters)

# Visualize the clustered images
plot_clusters(labels, image_paths)